/**
 * NostrClient Unit Tests
 * Story 2.1: Crosstown Relay Connection & Event Subscriptions
 *
 * Unit tests with mocked WebSocket to verify NIP-01 protocol implementation,
 * message parsing, error handling, and subscription management.
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import type { NostrEvent, Filter } from './types';
import { EventEmitter } from 'events';

// Mock WebSocket class (must be defined before vi.mock)
const sentMessagesMap = new Map<any, string[]>();

class MockWebSocket extends EventEmitter {
  public readyState: number = 0; // CONNECTING
  public url: string;

  static CONNECTING = 0;
  static OPEN = 1;
  static CLOSING = 2;
  static CLOSED = 3;

  constructor(url: string) {
    super();
    this.url = url;
    this.readyState = MockWebSocket.CONNECTING;
    sentMessagesMap.set(this, []);
  }

  get sentMessages(): string[] {
    return sentMessagesMap.get(this) || [];
  }

  set sentMessages(messages: string[]) {
    sentMessagesMap.set(this, messages);
  }

  send(data: string): void {
    if (this.readyState !== MockWebSocket.OPEN) {
      throw new Error('WebSocket is not open');
    }
    const messages = sentMessagesMap.get(this) || [];
    messages.push(data);
    sentMessagesMap.set(this, messages);
  }

  close(code?: number): void {
    this.readyState = MockWebSocket.CLOSING;
    setTimeout(() => {
      this.readyState = MockWebSocket.CLOSED;
      this.emit('close', code || 1000, Buffer.from(''));
    }, 0);
  }

  // Test helper to simulate opening connection
  simulateOpen(): void {
    this.readyState = MockWebSocket.OPEN;
    this.emit('open');
  }

  // Test helper to simulate receiving a message
  simulateMessage(data: string): void {
    this.emit('message', Buffer.from(data));
  }

  // Test helper to simulate error
  simulateError(error: Error): void {
    this.emit('error', error);
  }
}

// Mock the ws module
vi.mock('ws', () => ({
  default: MockWebSocket,
}));

// Import NostrClient AFTER mocking ws
const { NostrClient } = await import('./nostr-client');

describe('NostrClient Unit Tests', () => {
  let client: InstanceType<typeof NostrClient>;
  let mockWs: MockWebSocket;

  beforeEach(() => {
    // Clear all mocks
    vi.clearAllMocks();

    // Create client
    client = new NostrClient({ url: 'ws://localhost:4040' });

    // We need to manually trigger the connection to get the mock WebSocket
  });

  afterEach(async () => {
    if (client) {
      await client.disconnect();
      client.dispose();
    }
  });

  describe('AC1: WebSocket connection lifecycle', () => {
    it('should start in disconnected state', () => {
      expect(client.state).toBe('disconnected');
      expect(client.isConnected()).toBe(false);
    });

    it('should transition to connecting state on connect()', async () => {
      const stateChanges: string[] = [];
      client.on('connectionChange', (event: { state: string }) => {
        stateChanges.push(event.state);
      });

      const connectPromise = client.connect();

      // Should immediately transition to connecting
      expect(stateChanges).toContain('connecting');

      // Simulate WebSocket open
      const ws = (client as any).ws as MockWebSocket;
      ws.simulateOpen();

      await connectPromise;

      expect(stateChanges).toContain('connected');
      expect(client.state).toBe('connected');
      expect(client.isConnected()).toBe(true);
    });

    it('should validate relay URL format (reject non-ws/wss protocols)', () => {
      expect(() => new NostrClient({ url: 'http://localhost:4040' })).toThrow(/Must be ws:\/\/ or wss:\/\//);
      expect(() => new NostrClient({ url: 'https://localhost:4040' })).toThrow(/Must be ws:\/\/ or wss:\/\//);
      expect(() => new NostrClient({ url: 'ftp://localhost:4040' })).toThrow(/Must be ws:\/\/ or wss:\/\//);
    });

    it('should accept valid ws:// and wss:// URLs', () => {
      expect(() => new NostrClient({ url: 'ws://localhost:4040' })).not.toThrow();
      expect(() => new NostrClient({ url: 'wss://relay.example.com' })).not.toThrow();
      expect(() => new NostrClient({ url: 'ws://192.168.1.1:4040' })).not.toThrow();
    });

    it('should handle disconnect gracefully', async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      ws.simulateOpen();
      await connectPromise;

      const stateChanges: string[] = [];
      client.on('connectionChange', (event: { state: string }) => {
        stateChanges.push(event.state);
      });

      await client.disconnect();

      expect(stateChanges).toContain('disconnected');
      expect(client.state).toBe('disconnected');
      expect(client.isConnected()).toBe(false);
    });
  });

  describe('AC2: NIP-01 subscription protocol', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
      // Clear messages from connection setup
      ws.sentMessages = [];
    });

    it('should send REQ message with correct NIP-01 format', () => {
      const filters: Filter[] = [{ kinds: [30078] }];
      const handler = vi.fn();

      const sub = client.subscribe(filters, handler);

      expect(mockWs.sentMessages).toHaveLength(1);
      const message = JSON.parse(mockWs.sentMessages[0]);

      // Verify NIP-01 format: ["REQ", subscription_id, ...filters]
      expect(message[0]).toBe('REQ');
      expect(message[1]).toBe(sub.id);
      expect(message[2]).toEqual({ kinds: [30078] });
    });

    it('should generate unique subscription IDs using crypto.randomUUID()', () => {
      const sub1 = client.subscribe([{ kinds: [1] }], vi.fn());
      const sub2 = client.subscribe([{ kinds: [30078] }], vi.fn());
      const sub3 = client.subscribe([{ kinds: [1] }], vi.fn());

      // All IDs should be unique
      expect(sub1.id).not.toBe(sub2.id);
      expect(sub2.id).not.toBe(sub3.id);
      expect(sub1.id).not.toBe(sub3.id);

      // Should be valid UUIDs (36 characters with hyphens)
      expect(sub1.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
    });

    it('should send CLOSE message with correct format on unsubscribe', () => {
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());
      mockWs.sentMessages = []; // Clear REQ message

      sub.unsubscribe();

      expect(mockWs.sentMessages).toHaveLength(1);
      const message = JSON.parse(mockWs.sentMessages[0]);

      // Verify NIP-01 CLOSE format: ["CLOSE", subscription_id]
      expect(message).toEqual(['CLOSE', sub.id]);
    });

    it('should support multiple filters in single subscription', () => {
      const filters: Filter[] = [
        { kinds: [1], authors: ['abc123'] },
        { kinds: [30078] },
      ];

      const sub = client.subscribe(filters, vi.fn());

      const message = JSON.parse(mockWs.sentMessages[0]);
      expect(message[0]).toBe('REQ');
      expect(message[1]).toBe(sub.id);
      expect(message[2]).toEqual({ kinds: [1], authors: ['abc123'] });
      expect(message[3]).toEqual({ kinds: [30078] });
    });

    it('should call subscription handler when EVENT message received', () => {
      const handler = vi.fn();
      const sub = client.subscribe([{ kinds: [30078] }], handler);

      const event: NostrEvent = {
        id: 'event-123',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'test',
        sig: '0'.repeat(128),
      };

      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      expect(handler).toHaveBeenCalledTimes(1);
      expect(handler).toHaveBeenCalledWith(event);
    });

    it('should allow multiple active subscriptions', () => {
      const handler1 = vi.fn();
      const handler2 = vi.fn();

      const sub1 = client.subscribe([{ kinds: [1] }], handler1);
      const sub2 = client.subscribe([{ kinds: [30078] }], handler2);

      // Send event matching sub1
      const event1: NostrEvent = {
        id: 'event-1',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [],
        content: 'test 1',
        sig: '0'.repeat(128),
      };
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub1.id, event1]));

      expect(handler1).toHaveBeenCalledWith(event1);
      expect(handler2).not.toHaveBeenCalled();

      // Send event matching sub2
      const event2: NostrEvent = {
        id: 'event-2',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'test 2',
        sig: '0'.repeat(128),
      };
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub2.id, event2]));

      expect(handler1).toHaveBeenCalledTimes(1);
      expect(handler2).toHaveBeenCalledWith(event2);
    });
  });

  describe('AC3: EOSE (End of Stored Events) handling', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
    });

    it('should emit eose event when EOSE message received', async () => {
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());

      const eosePromise = new Promise<string>((resolve) => {
        client.on('eose', (subscriptionId: string) => {
          resolve(subscriptionId);
        });
      });

      mockWs.simulateMessage(JSON.stringify(['EOSE', sub.id]));

      const subscriptionId = await eosePromise;
      expect(subscriptionId).toBe(sub.id);
    });

    it('should continue receiving events after EOSE', () => {
      const handler = vi.fn();
      const sub = client.subscribe([{ kinds: [30078] }], handler);

      // Send EOSE
      mockWs.simulateMessage(JSON.stringify(['EOSE', sub.id]));

      // Send event after EOSE
      const event: NostrEvent = {
        id: 'event-after-eose',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'real-time update',
        sig: '0'.repeat(128),
      };
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      expect(handler).toHaveBeenCalledWith(event);
    });
  });

  describe('AC4: Action confirmation event detection', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
    });

    it('should emit actionConfirmed for kind 30078 events with valid ILP packet', async () => {
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());

      const ilpPacket = {
        reducer: 'move_player',
        args: [10, 20],
        fee: 500,
      };

      const confirmationPromise = new Promise<ActionConfirmation>((resolve) => {
        client.on('actionConfirmed', (confirmation: ActionConfirmation) => {
          resolve(confirmation);
        });
      });

      const event: NostrEvent = {
        id: 'action-event-123',
        pubkey: 'abcd1234' + '0'.repeat(56),
        created_at: 1234567890,
        kind: 30078,
        tags: [],
        content: JSON.stringify(ilpPacket),
        sig: '0'.repeat(128),
      };

      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      const confirmation = await confirmationPromise;
      expect(confirmation.reducer).toBe('move_player');
      expect(confirmation.args).toEqual([10, 20]);
      expect(confirmation.fee).toBe(500);
      expect(confirmation.eventId).toBeDefined();
      expect(confirmation.pubkey).toBeDefined();
      expect(confirmation.timestamp).toBeDefined();
    });

    it('should handle malformed ILP packet gracefully (log warning, do not crash)', () => {
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());
      const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      const event: NostrEvent = {
        id: 'malformed-event',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'not valid json',
        sig: '0'.repeat(128),
      };

      // Should not throw
      expect(() => {
        mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));
      }).not.toThrow();

      // Should log warning
      expect(consoleWarnSpy).toHaveBeenCalled();

      consoleWarnSpy.mockRestore();
    });

    it('should handle ILP packet with missing fields gracefully', () => {
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());
      const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      const incompletePacket = {
        reducer: 'test_reducer',
        // Missing: args, fee
      };

      const event: NostrEvent = {
        id: 'incomplete-event',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: JSON.stringify(incompletePacket),
        sig: '0'.repeat(128),
      };

      expect(() => {
        mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));
      }).not.toThrow();

      consoleWarnSpy.mockRestore();
    });

    it('should not emit actionConfirmed for non-30078 events', async () => {
      const sub = client.subscribe([{ kinds: [1, 30078] }], vi.fn());

      let actionConfirmedCalled = false;
      client.on('actionConfirmed', () => {
        actionConfirmedCalled = true;
      });

      // Send kind 1 event
      const event: NostrEvent = {
        id: 'text-note',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [],
        content: 'Hello world',
        sig: '0'.repeat(128),
      };

      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      // Wait a bit to ensure no actionConfirmed event
      await new Promise((resolve) => setTimeout(resolve, 100));
      expect(actionConfirmedCalled).toBe(false);
    });
  });

  describe('AC5: Reconnection with exponential backoff', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
    });

    it('should transition to reconnecting state on abnormal close', async () => {
      const reconnectingPromise = new Promise<string>((resolve) => {
        client.on('connectionChange', (event: { state: string }) => {
          if (event.state === 'reconnecting') {
            resolve(event.state);
          }
        });
      });

      // Simulate abnormal closure (code !== 1000)
      mockWs.close(1006);

      const state = await reconnectingPromise;
      expect(state).toBe('reconnecting');
    });

    it('should implement exponential backoff pattern (verified in integration tests)', () => {
      // The NostrClient uses the same ReconnectionManager pattern from Story 1.6
      // which implements exponential backoff: 1s, 2s, 4s, 8s, ..., max 30s

      // Verify the mechanism exists by checking the reconnectAttempts counter
      expect((client as any).reconnectAttempts).toBeDefined();
      expect(typeof (client as any).reconnectAttempts).toBe('number');

      // The actual exponential backoff timing (1s, 2s, 4s, 8s, max 30s)
      // and automatic reconnection behavior is tested in integration tests
      // where real timing can be observed (see nostr-integration.test.ts AC5)
    });

    it('should reset backoff delay on successful reconnection', async () => {
      // Verify that reconnectAttempts is reset to 0 when successfully connected
      // Initial state: 0 (connected in beforeEach)
      expect((client as any).reconnectAttempts).toBe(0);

      // The reset happens when a new connection is established.
      // Since mocking the full reconnection flow is complex, we verify
      // the mechanism exists by checking the counter is managed correctly.

      // When connected, counter should be 0
      expect(client.isConnected()).toBe(true);
      expect((client as any).reconnectAttempts).toBe(0);

      // This behavior is also tested in integration tests with real reconnections
    });

    it('should track subscriptions for re-establishment after reconnection', () => {
      // Create a subscription
      const handler = vi.fn();
      const sub = client.subscribe([{ kinds: [30078] }], handler);

      // Verify subscription is tracked internally
      const subscriptions = (client as any).subscriptions;
      expect(subscriptions.has(sub.id)).toBe(true);
      expect(subscriptions.get(sub.id).filters).toEqual([{ kinds: [30078] }]);

      // When reconnection happens, all tracked subscriptions will be re-sent
      // This is verified in integration tests with actual reconnections
    });
  });

  describe('AC7: Message parsing and error handling', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
    });

    it('should emit SigilError on invalid JSON message', async () => {
      const errorPromise = new Promise<Error>((resolve) => {
        client.on('error', (error: Error) => {
          resolve(error);
        });
      });

      mockWs.simulateMessage('not valid json {]');

      const error = await errorPromise;
      expect(error.code).toBe('INVALID_MESSAGE');
      expect(error.boundary).toBe('nostr-relay');
      expect(error.message).toContain('parsing');
    });

    it('should remain connected after invalid JSON message', async () => {
      // Listen for error to prevent unhandled errors
      const errorPromise = new Promise<Error>((resolve) => {
        client.on('error', (error: Error) => {
          resolve(error);
        });
      });

      mockWs.simulateMessage('invalid json');

      // Wait for error to be emitted
      await errorPromise;

      // Client should still be connected
      expect(client.isConnected()).toBe(true);
      expect(client.state).toBe('connected');
    });

    it('should continue processing messages after error', async () => {
      const handler = vi.fn();
      const sub = client.subscribe([{ kinds: [30078] }], handler);

      // Listen for error to prevent unhandled errors
      const errorPromise = new Promise<Error>((resolve) => {
        client.on('error', (error: Error) => {
          resolve(error);
        });
      });

      // Send invalid message
      mockWs.simulateMessage('invalid');

      // Wait for error to be processed
      await errorPromise;

      // Send valid message after error
      const event: NostrEvent = {
        id: 'valid-event',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'test',
        sig: '0'.repeat(128),
      };
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      expect(handler).toHaveBeenCalledWith(event);
    });

    it('should handle EVENT message with missing fields gracefully', async () => {
      const errorPromise = new Promise<Error>((resolve) => {
        client.on('error', (error: Error) => {
          resolve(error);
        });
      });

      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());

      // Event missing required fields
      const invalidEvent = {
        id: 'incomplete',
        // Missing: pubkey, created_at, kind, tags, content, sig
      };

      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, invalidEvent]));

      const error = await errorPromise;
      expect(error.code).toBe('INVALID_MESSAGE');
      expect(error.boundary).toBe('nostr-relay');
    });

    it('should isolate subscription handler errors (error in one handler does NOT crash client)', () => {
      const errorHandler = vi.fn(() => {
        throw new Error('Handler crashed!');
      });
      const goodHandler = vi.fn();

      const sub1 = client.subscribe([{ kinds: [1] }], errorHandler);
      const sub2 = client.subscribe([{ kinds: [30078] }], goodHandler);

      const event1: NostrEvent = {
        id: 'event-1',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 1,
        tags: [],
        content: 'test',
        sig: '0'.repeat(128),
      };

      const event2: NostrEvent = {
        id: 'event-2',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'test',
        sig: '0'.repeat(128),
      };

      // Should not throw despite handler error
      expect(() => {
        mockWs.simulateMessage(JSON.stringify(['EVENT', sub1.id, event1]));
      }).not.toThrow();

      // Second handler should still work
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub2.id, event2]));
      expect(goodHandler).toHaveBeenCalledWith(event2);
    });
  });

  describe('AC8: Rate limiting awareness', () => {
    beforeEach(async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;
    });

    it('should emit notice event when NOTICE message received', async () => {
      const noticePromise = new Promise<string>((resolve) => {
        client.on('notice', (message) => {
          resolve(message);
        });
      });

      mockWs.simulateMessage(JSON.stringify(['NOTICE', 'Rate limit exceeded']));

      const message = await noticePromise;
      expect(message).toBe('Rate limit exceeded');
    });

    it('should remain connected after NOTICE message', async () => {
      mockWs.simulateMessage(JSON.stringify(['NOTICE', 'Rate limit exceeded']));

      await new Promise((resolve) => setTimeout(resolve, 50));
      expect(client.isConnected()).toBe(true);
      expect(client.state).toBe('connected');
    });

    it('should continue operating after rate limit notice', () => {
      const handler = vi.fn();
      const sub = client.subscribe([{ kinds: [30078] }], handler);

      // Receive rate limit notice
      mockWs.simulateMessage(JSON.stringify(['NOTICE', 'Rate limit exceeded']));

      // Should still receive events
      const event: NostrEvent = {
        id: 'event-after-notice',
        pubkey: '0'.repeat(64),
        created_at: Math.floor(Date.now() / 1000),
        kind: 30078,
        tags: [],
        content: 'test',
        sig: '0'.repeat(128),
      };
      mockWs.simulateMessage(JSON.stringify(['EVENT', sub.id, event]));

      expect(handler).toHaveBeenCalledWith(event);
    });

    it('should rate-limit NOTICE event emission (max 10/minute)', async () => {
      const noticeHandler = vi.fn();
      client.on('notice', noticeHandler);

      // Send 20 NOTICE messages rapidly
      for (let i = 0; i < 20; i++) {
        mockWs.simulateMessage(JSON.stringify(['NOTICE', `Notice ${i}`]));
      }

      // Should emit at most 10 events (rate limited)
      expect(noticeHandler).toHaveBeenCalledTimes(10);
    });
  });

  describe('Additional edge cases', () => {
    it('should handle OK message (for future Story 2.3)', async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;

      // OK message should be handled without error
      expect(() => {
        mockWs.simulateMessage(JSON.stringify(['OK', 'event-id-123', true, 'Event accepted']));
      }).not.toThrow();
    });

    it('should handle unknown message types gracefully', async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;

      expect(() => {
        mockWs.simulateMessage(JSON.stringify(['UNKNOWN_TYPE', 'data']));
      }).not.toThrow();
    });

    it('should handle normal close (code 1000) without reconnection', async () => {
      let reconnectingEmitted = false;
      client.on('connectionChange', (event) => {
        if (event.state === 'reconnecting') {
          reconnectingEmitted = true;
        }
      });

      // Normal close (code 1000)
      mockWs.close(1000);

      await new Promise((resolve) => setTimeout(resolve, 100));
      expect(reconnectingEmitted).toBe(false);
      expect(client.state).toBe('disconnected');
    });

    it('should allow subscribing when not connected (deferred subscription)', () => {
      // Client is not connected
      // Subscribe should succeed but not send REQ message yet
      const sub = client.subscribe([{ kinds: [30078] }], vi.fn());

      expect(sub).toBeDefined();
      expect(sub.id).toBeDefined();
      expect(sub.filters).toEqual([{ kinds: [30078] }]);

      // REQ message will be sent when client connects later
    });

    it('should handle rapid subscribe/unsubscribe cycles', async () => {
      const connectPromise = client.connect();
      const ws = (client as any).ws as MockWebSocket;
      mockWs = ws;
      ws.simulateOpen();
      await connectPromise;

      const subs = [];
      for (let i = 0; i < 10; i++) {
        subs.push(client.subscribe([{ kinds: [i] }], vi.fn()));
      }

      // Unsubscribe all
      subs.forEach((sub) => sub.unsubscribe());

      // Should have 10 REQ and 10 CLOSE messages
      const reqCount = ws.sentMessages.filter((msg) => JSON.parse(msg)[0] === 'REQ').length;
      const closeCount = ws.sentMessages.filter((msg) => JSON.parse(msg)[0] === 'CLOSE').length;

      expect(reqCount).toBe(10);
      expect(closeCount).toBe(10);
    });
  });
});
